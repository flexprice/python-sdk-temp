"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .dto_couponassociationresponse import (
    DtoCouponAssociationResponse,
    DtoCouponAssociationResponseTypedDict,
)
from .dto_creditgrantresponse import (
    DtoCreditGrantResponse,
    DtoCreditGrantResponseTypedDict,
)
from .dto_customerresponse import DtoCustomerResponse, DtoCustomerResponseTypedDict
from .dto_planresponse import DtoPlanResponse, DtoPlanResponseTypedDict
from .dto_subscriptionlineitemresponse import (
    DtoSubscriptionLineItemResponse,
    DtoSubscriptionLineItemResponseTypedDict,
)
from .dto_subscriptionphaseresponse import (
    DtoSubscriptionPhaseResponse,
    DtoSubscriptionPhaseResponseTypedDict,
)
from .subscription_subscriptionpause import (
    SubscriptionSubscriptionPause,
    SubscriptionSubscriptionPauseTypedDict,
)
from .types_billingcadence import TypesBillingCadence
from .types_billingcycle import TypesBillingCycle
from .types_billingperiod import TypesBillingPeriod
from .types_pausestatus import TypesPauseStatus
from .types_prorationbehavior import TypesProrationBehavior
from .types_status import TypesStatus
from .types_subscriptionstatus import TypesSubscriptionStatus
from flexprice_sdk_test.models import components
from flexprice_sdk_test.types import BaseModel, UNSET_SENTINEL
from pydantic import field_serializer, model_serializer
from typing import Dict, List, Optional
from typing_extensions import NotRequired, TypedDict


class DtoSubscriptionResponseV2TypedDict(TypedDict):
    active_pause_id: NotRequired[str]
    r"""ActivePauseID references the current active pause configuration
    This will be null if no pause is active or scheduled
    """
    billing_anchor: NotRequired[str]
    r"""BillingAnchor is the reference point that aligns future billing cycle dates.
    It sets the day of week for week intervals, the day of month for month and year intervals,
    and the month of year for year intervals. The timestamp is in UTC format.
    """
    billing_cadence: NotRequired[TypesBillingCadence]
    billing_cycle: NotRequired[TypesBillingCycle]
    billing_period: NotRequired[TypesBillingPeriod]
    billing_period_count: NotRequired[int]
    r"""BillingPeriodCount is the total number units of the billing period."""
    cancel_at: NotRequired[str]
    r"""CancelAt is the date the subscription will be canceled"""
    cancel_at_period_end: NotRequired[bool]
    r"""CancelAtPeriodEnd is whether the subscription was canceled at the end of the current period"""
    cancelled_at: NotRequired[str]
    r"""CanceledAt is the date the subscription was canceled"""
    collection_method: NotRequired[str]
    r"""CollectionMethod determines how invoices are collected"""
    commitment_amount: NotRequired[str]
    r"""CommitmentAmount is the minimum amount a customer commits to paying for a billing period"""
    coupon_associations: NotRequired[List[DtoCouponAssociationResponseTypedDict]]
    r"""CouponAssociations are included when \"coupon_associations\" is in expand parameter"""
    created_at: NotRequired[str]
    created_by: NotRequired[str]
    credit_grants: NotRequired[List[DtoCreditGrantResponseTypedDict]]
    r"""CreditGrants are included when \"credit_grants\" is in expand parameter"""
    currency: NotRequired[str]
    r"""Currency is the currency of the subscription in lowercase 3 digit ISO codes"""
    current_period_end: NotRequired[str]
    r"""CurrentPeriodEnd is the end of the current period that the subscription has been invoiced for.
    At the end of this period, a new invoice will be created.
    """
    current_period_start: NotRequired[str]
    r"""CurrentPeriodStart is the end of the current period that the subscription has been invoiced for.
    At the end of this period, a new invoice will be created.
    """
    customer: NotRequired[DtoCustomerResponseTypedDict]
    r"""Customer response object containing all customer information"""
    customer_id: NotRequired[str]
    r"""CustomerID is the identifier for the customer in our system"""
    customer_timezone: NotRequired[str]
    enable_true_up: NotRequired[bool]
    end_date: NotRequired[str]
    r"""EndDate is the end date of the subscription"""
    environment_id: NotRequired[str]
    r"""EnvironmentID is the environment identifier for the subscription"""
    gateway_payment_method_id: NotRequired[str]
    r"""GatewayPaymentMethodID is the gateway payment method ID for this subscription"""
    id: NotRequired[str]
    r"""ID is the unique identifier for the subscription"""
    invoicing_customer_id: NotRequired[str]
    r"""InvoicingCustomerID is the customer ID to use for invoicing
    This can differ from the subscription customer (e.g., parent company invoicing for child company)
    """
    line_items: NotRequired[List[DtoSubscriptionLineItemResponseTypedDict]]
    r"""LineItems is expanded only if \"subscription_line_items\" is in expand parameter
    Each line item can optionally include expanded price data
    """
    lookup_key: NotRequired[str]
    r"""LookupKey is the key used to lookup the subscription in our system"""
    metadata: NotRequired[Dict[str, str]]
    overage_factor: NotRequired[str]
    r"""OverageFactor is a multiplier applied to usage beyond the commitment amount"""
    pause_status: NotRequired[TypesPauseStatus]
    pauses: NotRequired[List[SubscriptionSubscriptionPauseTypedDict]]
    r"""Pauses are included when subscription has pause status"""
    payment_behavior: NotRequired[str]
    r"""PaymentBehavior determines how subscription payments are handled"""
    phases: NotRequired[List[DtoSubscriptionPhaseResponseTypedDict]]
    r"""Phases are included when \"phases\" is in expand parameter"""
    plan: NotRequired[DtoPlanResponseTypedDict]
    plan_id: NotRequired[str]
    r"""PlanID is the identifier for the plan in our system"""
    proration_behavior: NotRequired[TypesProrationBehavior]
    start_date: NotRequired[str]
    r"""StartDate is the start date of the subscription"""
    status: NotRequired[TypesStatus]
    subscription_status: NotRequired[TypesSubscriptionStatus]
    tenant_id: NotRequired[str]
    trial_end: NotRequired[str]
    r"""TrialEnd is the end date of the trial period"""
    trial_start: NotRequired[str]
    r"""TrialStart is the start date of the trial period"""
    updated_at: NotRequired[str]
    updated_by: NotRequired[str]
    version: NotRequired[int]
    r"""Version is used for optimistic locking"""


class DtoSubscriptionResponseV2(BaseModel):
    active_pause_id: Optional[str] = None
    r"""ActivePauseID references the current active pause configuration
    This will be null if no pause is active or scheduled
    """

    billing_anchor: Optional[str] = None
    r"""BillingAnchor is the reference point that aligns future billing cycle dates.
    It sets the day of week for week intervals, the day of month for month and year intervals,
    and the month of year for year intervals. The timestamp is in UTC format.
    """

    billing_cadence: Optional[TypesBillingCadence] = None

    billing_cycle: Optional[TypesBillingCycle] = None

    billing_period: Optional[TypesBillingPeriod] = None

    billing_period_count: Optional[int] = None
    r"""BillingPeriodCount is the total number units of the billing period."""

    cancel_at: Optional[str] = None
    r"""CancelAt is the date the subscription will be canceled"""

    cancel_at_period_end: Optional[bool] = None
    r"""CancelAtPeriodEnd is whether the subscription was canceled at the end of the current period"""

    cancelled_at: Optional[str] = None
    r"""CanceledAt is the date the subscription was canceled"""

    collection_method: Optional[str] = None
    r"""CollectionMethod determines how invoices are collected"""

    commitment_amount: Optional[str] = None
    r"""CommitmentAmount is the minimum amount a customer commits to paying for a billing period"""

    coupon_associations: Optional[List[DtoCouponAssociationResponse]] = None
    r"""CouponAssociations are included when \"coupon_associations\" is in expand parameter"""

    created_at: Optional[str] = None

    created_by: Optional[str] = None

    credit_grants: Optional[List[DtoCreditGrantResponse]] = None
    r"""CreditGrants are included when \"credit_grants\" is in expand parameter"""

    currency: Optional[str] = None
    r"""Currency is the currency of the subscription in lowercase 3 digit ISO codes"""

    current_period_end: Optional[str] = None
    r"""CurrentPeriodEnd is the end of the current period that the subscription has been invoiced for.
    At the end of this period, a new invoice will be created.
    """

    current_period_start: Optional[str] = None
    r"""CurrentPeriodStart is the end of the current period that the subscription has been invoiced for.
    At the end of this period, a new invoice will be created.
    """

    customer: Optional[DtoCustomerResponse] = None
    r"""Customer response object containing all customer information"""

    customer_id: Optional[str] = None
    r"""CustomerID is the identifier for the customer in our system"""

    customer_timezone: Optional[str] = None

    enable_true_up: Optional[bool] = None

    end_date: Optional[str] = None
    r"""EndDate is the end date of the subscription"""

    environment_id: Optional[str] = None
    r"""EnvironmentID is the environment identifier for the subscription"""

    gateway_payment_method_id: Optional[str] = None
    r"""GatewayPaymentMethodID is the gateway payment method ID for this subscription"""

    id: Optional[str] = None
    r"""ID is the unique identifier for the subscription"""

    invoicing_customer_id: Optional[str] = None
    r"""InvoicingCustomerID is the customer ID to use for invoicing
    This can differ from the subscription customer (e.g., parent company invoicing for child company)
    """

    line_items: Optional[List[DtoSubscriptionLineItemResponse]] = None
    r"""LineItems is expanded only if \"subscription_line_items\" is in expand parameter
    Each line item can optionally include expanded price data
    """

    lookup_key: Optional[str] = None
    r"""LookupKey is the key used to lookup the subscription in our system"""

    metadata: Optional[Dict[str, str]] = None

    overage_factor: Optional[str] = None
    r"""OverageFactor is a multiplier applied to usage beyond the commitment amount"""

    pause_status: Optional[TypesPauseStatus] = None

    pauses: Optional[List[SubscriptionSubscriptionPause]] = None
    r"""Pauses are included when subscription has pause status"""

    payment_behavior: Optional[str] = None
    r"""PaymentBehavior determines how subscription payments are handled"""

    phases: Optional[List[DtoSubscriptionPhaseResponse]] = None
    r"""Phases are included when \"phases\" is in expand parameter"""

    plan: Optional[DtoPlanResponse] = None

    plan_id: Optional[str] = None
    r"""PlanID is the identifier for the plan in our system"""

    proration_behavior: Optional[TypesProrationBehavior] = None

    start_date: Optional[str] = None
    r"""StartDate is the start date of the subscription"""

    status: Optional[TypesStatus] = None

    subscription_status: Optional[TypesSubscriptionStatus] = None

    tenant_id: Optional[str] = None

    trial_end: Optional[str] = None
    r"""TrialEnd is the end date of the trial period"""

    trial_start: Optional[str] = None
    r"""TrialStart is the start date of the trial period"""

    updated_at: Optional[str] = None

    updated_by: Optional[str] = None

    version: Optional[int] = None
    r"""Version is used for optimistic locking"""

    @field_serializer("billing_cadence")
    def serialize_billing_cadence(self, value):
        if isinstance(value, str):
            try:
                return components.TypesBillingCadence(value)
            except ValueError:
                return value
        return value

    @field_serializer("billing_cycle")
    def serialize_billing_cycle(self, value):
        if isinstance(value, str):
            try:
                return components.TypesBillingCycle(value)
            except ValueError:
                return value
        return value

    @field_serializer("billing_period")
    def serialize_billing_period(self, value):
        if isinstance(value, str):
            try:
                return components.TypesBillingPeriod(value)
            except ValueError:
                return value
        return value

    @field_serializer("pause_status")
    def serialize_pause_status(self, value):
        if isinstance(value, str):
            try:
                return components.TypesPauseStatus(value)
            except ValueError:
                return value
        return value

    @field_serializer("proration_behavior")
    def serialize_proration_behavior(self, value):
        if isinstance(value, str):
            try:
                return components.TypesProrationBehavior(value)
            except ValueError:
                return value
        return value

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return components.TypesStatus(value)
            except ValueError:
                return value
        return value

    @field_serializer("subscription_status")
    def serialize_subscription_status(self, value):
        if isinstance(value, str):
            try:
                return components.TypesSubscriptionStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "active_pause_id",
                "billing_anchor",
                "billing_cadence",
                "billing_cycle",
                "billing_period",
                "billing_period_count",
                "cancel_at",
                "cancel_at_period_end",
                "cancelled_at",
                "collection_method",
                "commitment_amount",
                "coupon_associations",
                "created_at",
                "created_by",
                "credit_grants",
                "currency",
                "current_period_end",
                "current_period_start",
                "customer",
                "customer_id",
                "customer_timezone",
                "enable_true_up",
                "end_date",
                "environment_id",
                "gateway_payment_method_id",
                "id",
                "invoicing_customer_id",
                "line_items",
                "lookup_key",
                "metadata",
                "overage_factor",
                "pause_status",
                "pauses",
                "payment_behavior",
                "phases",
                "plan",
                "plan_id",
                "proration_behavior",
                "start_date",
                "status",
                "subscription_status",
                "tenant_id",
                "trial_end",
                "trial_start",
                "updated_at",
                "updated_by",
                "version",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
