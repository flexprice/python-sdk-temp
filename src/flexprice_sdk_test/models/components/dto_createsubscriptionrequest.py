"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .dto_addaddontosubscriptionrequest import (
    DtoAddAddonToSubscriptionRequest,
    DtoAddAddonToSubscriptionRequestTypedDict,
)
from .dto_createcreditgrantrequest import (
    DtoCreateCreditGrantRequest,
    DtoCreateCreditGrantRequestTypedDict,
)
from .dto_lineitemcommitmentconfig import (
    DtoLineItemCommitmentConfig,
    DtoLineItemCommitmentConfigTypedDict,
)
from .dto_overrideentitlementrequest import (
    DtoOverrideEntitlementRequest,
    DtoOverrideEntitlementRequestTypedDict,
)
from .dto_overridelineitemrequest import (
    DtoOverrideLineItemRequest,
    DtoOverrideLineItemRequestTypedDict,
)
from .dto_subscriptionphasecreaterequest import (
    DtoSubscriptionPhaseCreateRequest,
    DtoSubscriptionPhaseCreateRequestTypedDict,
)
from .dto_taxrateoverride import DtoTaxRateOverride, DtoTaxRateOverrideTypedDict
from .types_billingcadence import TypesBillingCadence
from .types_billingcycle import TypesBillingCycle
from .types_billingperiod import TypesBillingPeriod
from .types_collectionmethod import TypesCollectionMethod
from .types_invoicebilling import TypesInvoiceBilling
from .types_paymentbehavior import TypesPaymentBehavior
from .types_prorationbehavior import TypesProrationBehavior
from .types_subscriptionstatus import TypesSubscriptionStatus
from flexprice_sdk_test.models import components
from flexprice_sdk_test.types import BaseModel, UNSET_SENTINEL
from pydantic import field_serializer, model_serializer
from typing import Dict, List, Optional
from typing_extensions import NotRequired, TypedDict


class DtoCreateSubscriptionRequestTypedDict(TypedDict):
    billing_cadence: TypesBillingCadence
    billing_period: TypesBillingPeriod
    currency: str
    plan_id: str
    addons: NotRequired[List[DtoAddAddonToSubscriptionRequestTypedDict]]
    r"""Addons represents addons to be added to the subscription during creation"""
    billing_cycle: NotRequired[TypesBillingCycle]
    billing_period_count: NotRequired[int]
    collection_method: NotRequired[TypesCollectionMethod]
    commitment_amount: NotRequired[str]
    r"""CommitmentAmount is the minimum amount a customer commits to paying for a billing period"""
    coupons: NotRequired[List[str]]
    credit_grants: NotRequired[List[DtoCreateCreditGrantRequestTypedDict]]
    r"""Credit grants to be applied when subscription is created"""
    customer_id: NotRequired[str]
    r"""customer_id is the flexprice customer id
    and it is prioritized over external_customer_id in case both are provided.
    """
    customer_timezone: NotRequired[str]
    r"""Timezone of the customer.
    If not set, the default value is UTC.
    """
    enable_true_up: NotRequired[bool]
    r"""Enable Commitment True Up Fee"""
    end_date: NotRequired[str]
    external_customer_id: NotRequired[str]
    r"""external_customer_id is the customer id in your DB
    and must be same as what you provided as external_id while creating the customer in flexprice.
    """
    gateway_payment_method_id: NotRequired[str]
    invoice_billing: NotRequired[TypesInvoiceBilling]
    line_item_commitments: NotRequired[Dict[str, DtoLineItemCommitmentConfigTypedDict]]
    r"""LineItemCommitments allows setting commitment configuration per line item (keyed by price_id)"""
    line_item_coupons: NotRequired[Dict[str, List[str]]]
    lookup_key: NotRequired[str]
    metadata: NotRequired[Dict[str, str]]
    overage_factor: NotRequired[str]
    r"""OverageFactor is a multiplier applied to usage beyond the commitment amount"""
    override_entitlements: NotRequired[List[DtoOverrideEntitlementRequestTypedDict]]
    r"""OverrideEntitlements allows customizing specific entitlements for this subscription"""
    override_line_items: NotRequired[List[DtoOverrideLineItemRequestTypedDict]]
    r"""OverrideLineItems allows customizing specific prices for this subscription"""
    payment_behavior: NotRequired[TypesPaymentBehavior]
    phases: NotRequired[List[DtoSubscriptionPhaseCreateRequestTypedDict]]
    r"""Phases represents subscription phases to be created with the subscription"""
    proration_behavior: NotRequired[TypesProrationBehavior]
    start_date: NotRequired[str]
    subscription_status: NotRequired[TypesSubscriptionStatus]
    tax_rate_overrides: NotRequired[List[DtoTaxRateOverrideTypedDict]]
    r"""tax_rate_overrides is the tax rate overrides	to be applied to the subscription"""
    trial_end: NotRequired[str]
    trial_start: NotRequired[str]


class DtoCreateSubscriptionRequest(BaseModel):
    billing_cadence: TypesBillingCadence

    billing_period: TypesBillingPeriod

    currency: str

    plan_id: str

    addons: Optional[List[DtoAddAddonToSubscriptionRequest]] = None
    r"""Addons represents addons to be added to the subscription during creation"""

    billing_cycle: Optional[TypesBillingCycle] = None

    billing_period_count: Optional[int] = None

    collection_method: Optional[TypesCollectionMethod] = None

    commitment_amount: Optional[str] = None
    r"""CommitmentAmount is the minimum amount a customer commits to paying for a billing period"""

    coupons: Optional[List[str]] = None

    credit_grants: Optional[List[DtoCreateCreditGrantRequest]] = None
    r"""Credit grants to be applied when subscription is created"""

    customer_id: Optional[str] = None
    r"""customer_id is the flexprice customer id
    and it is prioritized over external_customer_id in case both are provided.
    """

    customer_timezone: Optional[str] = None
    r"""Timezone of the customer.
    If not set, the default value is UTC.
    """

    enable_true_up: Optional[bool] = None
    r"""Enable Commitment True Up Fee"""

    end_date: Optional[str] = None

    external_customer_id: Optional[str] = None
    r"""external_customer_id is the customer id in your DB
    and must be same as what you provided as external_id while creating the customer in flexprice.
    """

    gateway_payment_method_id: Optional[str] = None

    invoice_billing: Optional[TypesInvoiceBilling] = None

    line_item_commitments: Optional[Dict[str, DtoLineItemCommitmentConfig]] = None
    r"""LineItemCommitments allows setting commitment configuration per line item (keyed by price_id)"""

    line_item_coupons: Optional[Dict[str, List[str]]] = None

    lookup_key: Optional[str] = None

    metadata: Optional[Dict[str, str]] = None

    overage_factor: Optional[str] = None
    r"""OverageFactor is a multiplier applied to usage beyond the commitment amount"""

    override_entitlements: Optional[List[DtoOverrideEntitlementRequest]] = None
    r"""OverrideEntitlements allows customizing specific entitlements for this subscription"""

    override_line_items: Optional[List[DtoOverrideLineItemRequest]] = None
    r"""OverrideLineItems allows customizing specific prices for this subscription"""

    payment_behavior: Optional[TypesPaymentBehavior] = None

    phases: Optional[List[DtoSubscriptionPhaseCreateRequest]] = None
    r"""Phases represents subscription phases to be created with the subscription"""

    proration_behavior: Optional[TypesProrationBehavior] = None

    start_date: Optional[str] = None

    subscription_status: Optional[TypesSubscriptionStatus] = None

    tax_rate_overrides: Optional[List[DtoTaxRateOverride]] = None
    r"""tax_rate_overrides is the tax rate overrides	to be applied to the subscription"""

    trial_end: Optional[str] = None

    trial_start: Optional[str] = None

    @field_serializer("billing_cadence")
    def serialize_billing_cadence(self, value):
        if isinstance(value, str):
            try:
                return components.TypesBillingCadence(value)
            except ValueError:
                return value
        return value

    @field_serializer("billing_cycle")
    def serialize_billing_cycle(self, value):
        if isinstance(value, str):
            try:
                return components.TypesBillingCycle(value)
            except ValueError:
                return value
        return value

    @field_serializer("billing_period")
    def serialize_billing_period(self, value):
        if isinstance(value, str):
            try:
                return components.TypesBillingPeriod(value)
            except ValueError:
                return value
        return value

    @field_serializer("proration_behavior")
    def serialize_proration_behavior(self, value):
        if isinstance(value, str):
            try:
                return components.TypesProrationBehavior(value)
            except ValueError:
                return value
        return value

    @field_serializer("subscription_status")
    def serialize_subscription_status(self, value):
        if isinstance(value, str):
            try:
                return components.TypesSubscriptionStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "addons",
                "billing_cycle",
                "billing_period_count",
                "collection_method",
                "commitment_amount",
                "coupons",
                "credit_grants",
                "customer_id",
                "customer_timezone",
                "enable_true_up",
                "end_date",
                "external_customer_id",
                "gateway_payment_method_id",
                "invoice_billing",
                "line_item_commitments",
                "line_item_coupons",
                "lookup_key",
                "metadata",
                "overage_factor",
                "override_entitlements",
                "override_line_items",
                "payment_behavior",
                "phases",
                "proration_behavior",
                "start_date",
                "subscription_status",
                "tax_rate_overrides",
                "trial_end",
                "trial_start",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
